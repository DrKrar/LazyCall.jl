<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LazyCall.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>LazyCall.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="LazyCall.jl-1" href="#LazyCall.jl-1">LazyCall.jl</a></h1><p>LazyCall allows you to store a function along with its arguments for later use. This is particularly useful in functional programming.</p><p>Methods on LazyCalls are currently defined for one <code>Base</code> function: <code>broadcast</code>. Use <a href="index.html#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>lazy_call_methods</code></a> to easily define more.</p><ul><li><a href="index.html#LazyCall.Call"><code>LazyCall.Call</code></a></li><li><a href="index.html#LazyCall.bit_not"><code>LazyCall.bit_not</code></a></li><li><a href="index.html#LazyCall.collect_call-Tuple"><code>LazyCall.collect_call</code></a></li><li><a href="index.html#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>LazyCall.lazy_call_methods</code></a></li><li><a href="index.html#LazyCall.unweave-Tuple{Any}"><code>LazyCall.unweave</code></a></li><li><a href="index.html#LazyCall.@lazy_call_methods"><code>LazyCall.@lazy_call_methods</code></a></li><li><a href="index.html#LazyCall.@unweave"><code>LazyCall.@unweave</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.Call" href="#LazyCall.Call"><code>LazyCall.Call</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">immutable Call</code></pre><p>Will store positional and keyword arguments. Create with <a href="index.html#LazyCall.collect_call-Tuple"><code>collect_call</code></a> or <a href="index.html#LazyCall.unweave-Tuple{Any}"><code>unweave</code></a>.</p><p>You can include positional arguments, keyword arguments, or both.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(1, 2)
1, 2

julia&gt; collect_call(a = 1, b = 2)
; a = 1, b = 2

julia&gt; collect_call(1, 2, a = 1, b = 2)
1, 2; a = 1, b = 2</code></pre><p>They are equal if all of their elements are equal and the positional arguments are in the right order. Keyword order doesn&#39;t matter.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(1, 2, a = 1, b = 2) == collect_call(1, 2, b = 2, a = 1)
true</code></pre><p>You can <code>copy</code> them to avoid accidentally overwriting keyword arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; test = collect_call(a = 1);

julia&gt; copy_test = copy(test);

julia&gt; copy_test.keyword[:b] = 2;

julia&gt; test.keyword == copy_test.keyword
false</code></pre><p>You can <code>merge</code> two <code>Call</code>s, optionally at a specific position.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; base = collect_call(1, 2, a = 3, b = 4);

julia&gt; addition = collect_call(5, a = 6, c = 7);

julia&gt; merge(base, addition) == collect_call(1, 2, 5; a = 6, b = 4, c = 7)
true

julia&gt; merge(base, addition, 2) == collect_call(1, 5, 2; a = 6, b = 4, c = 7)
true

julia&gt; merge(base, addition, 4)
ERROR: Call a must have at least position - 1 positional arguments
[...]</code></pre><p>You can <code>push</code>, <code>unshift</code>, or <code>insert</code> in new arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; base = collect_call(1, 2, a = 3, b = 4);

julia&gt; @chain begin
           push(base, 5, a = 6, c = 7)
           _ == collect_call(1, 2, 5; a = 6, b = 4, c = 7)
       end
true

julia&gt; @chain begin
           unshift(base, 5, a = 6, c = 7)
           _ == collect_call(5, 1, 2; a = 6, b = 4, c = 7)
       end
true

julia&gt; @chain begin
           insert(base, 2, 5, a = 6, c = 7)
           _ == collect_call(1, 5, 2; a = 6, b = 4, c = 7)
       end
true</code></pre><p>You can <code>run</code> a function on a call.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; @chain begin
           collect_call(1, 2)
           run(_, vcat)
       end
2-element Array{Int64,1}:
 1
 2</code></pre><p>If you <code>run</code> a <code>Call</code> by itself, it calls the first positional argument on the rest of the positional and keyword arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(vcat, 1, 2) |&gt; run
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/src/lazy_call.jl#L2-L115">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.bit_not" href="#LazyCall.bit_not"><code>LazyCall.bit_not</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bit_not</code></pre><p>Alias for <code>~</code> for use within <a href="index.html#LazyCall.@unweave"><code>@unweave</code></a>.</p><p><strong>examples</strong></p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; run(@unweave bit_not(1) ) == ~1
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/src/unweave.jl#L141-L153">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.collect_call-Tuple" href="#LazyCall.collect_call-Tuple"><code>LazyCall.collect_call</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">collect_call(positional...; keyword...)</code></pre><p>Collect a <a href="index.html#LazyCall.Call"><code>Call</code></a>.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(1, 2, a = 1, b = 2)
1, 2; a = 1, b = 2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/src/lazy_call.jl#L144-L155">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}" href="#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>LazyCall.lazy_call_methods</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@lazy_call_methods a_module fs...</code></pre><p>For each function in <code>fs</code> in <code>a_module</code>, create a method that takes a <a href="index.html#LazyCall.Call"><code>Call</code></a>. This method will make assumptions about argument order. Positional arguments from the outer call will be inserted between the first (typically a function) and second positional arguments of the inner [<code>Call</code>]. This makes sense in many cases. For more complicated cases, like <code>mapreducedim</code>, <code>Call</code> methods can be defined by hand.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; @lazy_call_methods Base Generator mapreduce

julia&gt; version_1 = @chain begin
           [-2, 0, -2, 0]
           @unweave ~_ + 1 &gt; 0
           Base.Generator(_)
           sum(_)
        end
2

julia&gt; version_2 = @chain begin
           [-2, 0, -2, 0]
           @unweave ~_ + 1 &gt; 0
           mapreduce(_, +)
       end
2

julia&gt; version_1 == version_2
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/src/methods.jl#L12-L45">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.@lazy_call_methods" href="#LazyCall.@lazy_call_methods"><code>LazyCall.@lazy_call_methods</code></a> — <span class="docstring-category">Macro</span>.</div><div><p>See documentation of <a href="index.html#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>lazy_call_methods</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/src/methods.jl#L49">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.@unweave" href="#LazyCall.@unweave"><code>LazyCall.@unweave</code></a> — <span class="docstring-category">Macro</span>.</div><div><p>See documentation of <a href="index.html#LazyCall.unweave-Tuple{Any}"><code>unweave</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/src/unweave.jl#L137">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.unweave-Tuple{Any}" href="#LazyCall.unweave-Tuple{Any}"><code>LazyCall.unweave</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@unweave e</code></pre><p>Interprets <code>e</code> as a function with its arguments wrapped in tildas and woven into it. Will return a <a href="index.html#LazyCall.Call"><code>Call</code></a>, with an anonymous function as the first positional argument.</p><p>Both variables and expressions can be woven in.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; A = [1, 2];

julia&gt; @chain begin
           @unweave vcat(~A, ~[3, 4] )
           broadcast(_)
           _ == broadcast(vcat, A, [3, 4] )
       end
true</code></pre><p>Variables need only be marked once as arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; A = [1, 2];

julia&gt; @chain begin
           @unweave vcat(~A, A)
           broadcast(_)
           _ == map(vcat, A, A)
       end
true</code></pre><p>No more than one splatted positional argument can be woven in.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; A = [1, 2], [3, 4];

julia&gt; B = [5, 6], [7, 8];

julia&gt; @chain begin
           @unweave vcat( ~(A...) )
           broadcast(_)
           _ == broadcast(vcat, A...)
       end
true

julia&gt; @unweave vcat( ~(A...), ~(B...) )
ERROR: syntax: invalid ... on non-final argument
[...]</code></pre><p>No more than one splatted keyword argument can be woven in.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; keyword_arguments(; kwargs...) = kwargs;

julia&gt; A = keyword_arguments( a = 1, b = 2);

julia&gt; B = keyword_arguments( c = 3, d = 4);

julia&gt; @chain begin
           @unweave keyword_arguments(; ~(A...) )
           run(_)
           _ == keyword_arguments(; A...)
       end
true

julia&gt; @unweave keyword_arguments(; ~( A...), ~(B...) )
ERROR: Can only weave in one (set of) parameters
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/e586e148bf579eb47ab5aa401d88edd1d3444a40/src/unweave.jl#L36-L112">source</a><br/></section><footer><hr/></footer></article></body></html>
