<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LazyCall.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>LazyCall.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="LazyCall.jl-1" href="#LazyCall.jl-1">LazyCall.jl</a></h1><p>LazyCall allows you to store a function along with its arguments for later use. This is particularly useful in functional programming.</p><p>Methods on LazyCalls are currently defined for one <code>Base</code> function: <code>broadcast</code>. Use <a href="index.html#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>lazy_call_methods</code></a> to easily define more.</p><ul><li><a href="index.html#LazyCall.Call"><code>LazyCall.Call</code></a></li><li><a href="index.html#LazyCall.bit_not"><code>LazyCall.bit_not</code></a></li><li><a href="index.html#LazyCall.collect_call-Tuple"><code>LazyCall.collect_call</code></a></li><li><a href="index.html#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>LazyCall.lazy_call_methods</code></a></li><li><a href="index.html#LazyCall.push-Tuple{LazyCall.Call,Vararg{Any,N} where N}"><code>LazyCall.push</code></a></li><li><a href="index.html#LazyCall.unshift-Tuple{LazyCall.Call,Vararg{Any,N} where N}"><code>LazyCall.unshift</code></a></li><li><a href="index.html#LazyCall.unweave-Tuple{Any}"><code>LazyCall.unweave</code></a></li><li><a href="index.html#LazyCall.@lazy_call_methods"><code>LazyCall.@lazy_call_methods</code></a></li><li><a href="index.html#LazyCall.@unweave"><code>LazyCall.@unweave</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.Call" href="#LazyCall.Call"><code>LazyCall.Call</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">immutable Call</code></pre><p>Will store positional and keyword arguments. Create with <a href="index.html#LazyCall.collect_call-Tuple"><code>collect_call</code></a> or <a href="index.html#LazyCall.unweave-Tuple{Any}"><code>unweave</code></a>.</p><p>You can include positional arguments, keyword arguments, or both.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(1, 2)
1, 2

julia&gt; collect_call(a = 1, b = 2)
; a = 1, b = 2

julia&gt; collect_call(1, 2, a = 1, b = 2)
1, 2; a = 1, b = 2</code></pre><p>They are equal if all of their elements are equal and the positional arguments are in the right order. Keyword order doesn&#39;t matter.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(1, 2, a = 1, b = 2) == collect_call(1, 2, b = 2, a = 1)
true</code></pre><p>You can <code>merge</code> two <code>Call</code>s.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; @chain begin
           merge(
               collect_call(1, a = 2, b = 3),
               collect_call(4, a = 5, c = 6)
            )
            _ == collect_call(1, 4; a = 5, b = 3, c = 6)
       end
true</code></pre><p>You can <a href="index.html#LazyCall.push-Tuple{LazyCall.Call,Vararg{Any,N} where N}"><code>push</code></a> in new arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; @chain begin
           collect_call(1, a = 2, b = 3)
           push(_, 4, a = 5, c = 6)
           _ == collect_call(1, 4; a = 5, b = 3, c = 6)
       end
true</code></pre><p>You can <a href="index.html#LazyCall.unshift-Tuple{LazyCall.Call,Vararg{Any,N} where N}"><code>unshift</code></a> in new arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; @chain begin
           collect_call(1, a = 2, b = 3)
           unshift(_, 4, a = 5, c = 6)
           _ == collect_call(4, 1; a = 2, b = 3, c = 6)
       end
true</code></pre><p>When you <code>run</code> a <code>Call</code>, it calls the first positional argument on the rest of the positional and keyword arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(vcat, 1, 2) |&gt; run
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/lazy_call.jl#L2-L80">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.bit_not" href="#LazyCall.bit_not"><code>LazyCall.bit_not</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bit_not</code></pre><p>Alias for <code>~</code> for use within <a href="index.html#LazyCall.@unweave"><code>@unweave</code></a>.</p><p><strong>examples</strong></p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; bit_not(1) == ~1
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/unweave.jl#L150-L162">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.collect_call-Tuple" href="#LazyCall.collect_call-Tuple"><code>LazyCall.collect_call</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">collect_call(positional...; keyword...)</code></pre><p>Collect a <a href="index.html#LazyCall.Call"><code>Call</code></a>.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; collect_call(1, 2, a = 1, b = 2)
1, 2; a = 1, b = 2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/lazy_call.jl#L108-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}" href="#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>LazyCall.lazy_call_methods</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@lazy_call_methods a_module fs...</code></pre><p>For each function in <code>fs</code> in <code>a_module</code>, create a method that takes a <a href="index.html#LazyCall.Call"><code>Call</code></a>. This method will make assumptions about argument order. Positional arguments from the outer call will be inserted between the first (typically a function) and second positional arguments of the inner [<code>Call</code>]. This makes sense in many cases. For more complicated cases, like <code>mapreducedim</code>, <code>Call</code> methods can be defined by hand.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; @lazy_call_methods Base Generator mapreduce

julia&gt; version_1 = @chain begin
           [-2, 0, -2, 0]
           @unweave ~_ + 1 &gt; 0
           Base.Generator(_)
           sum(_)
        end
2

julia&gt; version_2 = @chain begin
           [-2, 0, -2, 0]
           @unweave ~_ + 1 &gt; 0
           mapreduce(_, +)
       end
2

julia&gt; version_1 == version_2
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/methods.jl#L17-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.push-Tuple{LazyCall.Call,Vararg{Any,N} where N}" href="#LazyCall.push-Tuple{LazyCall.Call,Vararg{Any,N} where N}"><code>LazyCall.push</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">push</code></pre><p>Same as <code>push!</code> but will leave arguments unchanged.</p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/lazy_call.jl#L90-L94">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.unshift-Tuple{LazyCall.Call,Vararg{Any,N} where N}" href="#LazyCall.unshift-Tuple{LazyCall.Call,Vararg{Any,N} where N}"><code>LazyCall.unshift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">unshift</code></pre><p>Same as <code>unshift!</code> but will leave arguments unchanged.</p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/lazy_call.jl#L99-L103">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.@lazy_call_methods" href="#LazyCall.@lazy_call_methods"><code>LazyCall.@lazy_call_methods</code></a> — <span class="docstring-category">Macro</span>.</div><div><p>See documentation of <a href="index.html#LazyCall.lazy_call_methods-Tuple{Any,Vararg{Any,N} where N}"><code>lazy_call_methods</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/methods.jl#L54">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.@unweave" href="#LazyCall.@unweave"><code>LazyCall.@unweave</code></a> — <span class="docstring-category">Macro</span>.</div><div><p>See documentation of <a href="index.html#LazyCall.unweave-Tuple{Any}"><code>unweave</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/unweave.jl#L146">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyCall.unweave-Tuple{Any}" href="#LazyCall.unweave-Tuple{Any}"><code>LazyCall.unweave</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@unweave e</code></pre><p>Interprets <code>e</code> as a function with its arguments wrapped in tildas and woven into it. Will return a <a href="index.html#LazyCall.Call"><code>Call</code></a>, with an anonymous function as the first positional argument.</p><p>Both variables and expressions can be woven in.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; A = [1, 2];

julia&gt; @chain begin
           @unweave vcat(~A, ~[3, 4] )
           broadcast(_)
           _ == broadcast(vcat, A, [3, 4] )
       end
true</code></pre><p>Variables need only be marked once as arguments.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; A = [1, 2];

julia&gt; @chain begin
           @unweave vcat(~A, A)
           broadcast(_)
           _ == map(vcat, A, A)
       end
true</code></pre><p>No more than one splatted positional argument can be woven in.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; A = [1, 2], [3, 4];

julia&gt; B = [5, 6], [7, 8];

julia&gt; @chain begin
           @unweave vcat( ~(A...) )
           broadcast(_)
           _ == broadcast(vcat, A...)
       end
true

julia&gt; @unweave vcat( ~(A...), ~(B...) )
ERROR: syntax: invalid ... on non-final argument
[...]</code></pre><p>No more than one splatted keyword argument can be woven in.</p><pre><code class="language-jlcon">julia&gt; using LazyCall, ChainRecursive

julia&gt; keyword_arguments(; kwargs...) = kwargs;

julia&gt; A = keyword_arguments( a = 1, b = 2);

julia&gt; B = keyword_arguments( c = 3, d = 4);

julia&gt; @chain begin
           @unweave keyword_arguments(; ~(A...) )
           run(_)
           _ == keyword_arguments(; A...)
       end
true

julia&gt; @unweave keyword_arguments(; ~( A...), ~(B...) )
ERROR: Can only weave in one (set of) parameters
[...]</code></pre><p>With no woven arguments, <code>Call</code> will only contain a dummy anonymous function.</p><pre><code class="language-jlcon">julia&gt; using LazyCall

julia&gt; run(@unweave 1)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyCall.jl/tree/86c5f5d3e1bf2d90ba308db0bb3a2a84c606611c/src/unweave.jl#L36-L121">source</a><br/></section><footer><hr/></footer></article></body></html>
